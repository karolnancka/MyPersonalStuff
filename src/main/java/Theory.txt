1. Wzorzec projektowy przedstawia typowe rozwiązanie problemów często napotkanych przy tworzeniu oprogramowania.
   Stanowi coś na kształt gotowego planu, który można dostosować, aby rozwiązać powtarzający się problem w kodzie.
   Wzorzec nie jest konkretnym fragmentem kodu, który można skopiować i rozwiązać nim dany problem, ale ogólną koncepcją
   pozwalającą rozwiązać dany problem.

   Wzorce często myli się z algorytmami, ponieważ obie koncepcje opisują typowe rozwiązanie jakiegoś znanego problemu.
   Algorytm jednak zawsze definiuje wyraźny zestaw czynności które prowadzą do celu, zaś wzorzec to wysokopoziomowy opis rozwiązania.
   Kod powstały na podstawie jednego wzorca może wyglądać zupełnie inaczej w różnych programach.

2. SOLID
    Single Resposibility Principle
    Zasada mówi o tym, że klasa powinna mieć wyłącznie jeden powód do zmiany.
    Wytyczna ta sprowadza się do tego, że dana klasa powinna mieć jeden główny cel.
    Jedną główną odpowiedzialność. Jedną funkcjonalność, którą realizuje.
    Twoje klasy powinny mieć motto: rób jedną rzecz, rób tę rzecz dobrze.

    Open/Closed Principle
    Kod, który tworzymy chcemy aby był “możliwy do rozszerzania i zamknięty na modyfikacje”.
    Sprowadza się do do świadomego użycia kompozycji, dziedziczenia czy modyfikatorów dostępu.

    Liskov Substitution Principle
    W przypadku tej wytycznej Twój kod powinien współpracować poprawnie z klasą, jak i wszystkimi jej podklasami.
    Innymi słowy jeśli zależysz od jakiegoś interfejsu to wszystkie jego implementacje powinny poprawnie działać z Twoją klasą/metodą.
    Stosowanie się do tej zasady pozwala na dostarczenie alternatywnej implementacji danej funkcjonalności bez zmiany Twojego kodu.

    Interface Segregation Principle.
    Wytyczna ta mówi o tym, abyś rozdzielał interfejs klasy. Interfejs ten powinien być odpowiednio zdefiniowany.
    Chodzi tu o aby inny fragment kodu, który używa Twojej klasy używał wyłącznie podzbioru metod, który jest w tamtym przypadku istotny.
    W oryginale wytyczna ta mówi o tym, ze klienty nie powinny być zmuszane do wprowadzania zależności od interfejsów, których nie używają.
    Jeśli będziesz stosował się do tej wytycznej to zmiany Twoich klas powinny być łatwiejsze do przeprowadzenia.
    Dzięki jasno zdefiniowanym interfejsom ryzyko zmiany klas, które używają tych interfejsów będzie mniejsze.

    Dependency Inversion Principle
    Wytyczna ta mówi, że wysokopoziomowe klasy nie powinny zależeć od niskopoziomowych detali.
    Zależność ta powinna być odwrócona poprzez wprowadzenie dodatkowych elementów.
    Mówi się tu o dodatkowych warstwach abstrakcji, które pozwalają na zmianę kierunku takiej zależności.

3. Dziedziczenie

   Jest to mechanizm, który pozwala na rozszerzanie funkcjonalności obiektów poprzez hierarchiczne powiązanie ich ze sobą tzn.
   jeden obiekt dziedziczy zachowania i stan od drugiego.

// Klasa Animal wraz z różnymi metodami

   public class Animal {
       public void eat() {
           System.out.println(this.getClass().getSimpleName() + " eat");
       }

       public void walk() {
           System.out.println(this.getClass().getSimpleName() + " walk");
       }

       public void sleep() {
           System.out.println(this.getClass().getSimpleName() + " sleep");
       }
   }

// Dziedziczenie po klasie Animal

   public class Dog extends Animal {
   }

   public class Cat extends Animal {
   }

//Korzystanie z metod klasy animal na obiektach typu Cat i Dog

public class Main {
    public static void main(String[] args) {
        Animal animal = new Animal();
        animal.eat();
        animal.walk();
        animal.sleep();
        Animal dog = new Dog();
        dog.eat();
        dog.walk();
        dog.sleep();
        Animal cat = new Cat();
        cat.eat();
        cat.walk();
        cat.sleep();
    }
}

4. Polimorfizm

   Kolejnym zagadnieniem związanym także z dziedziczeniem jest polimorfizm, czyli w skrócie wielopostaciowość.
   Klasy pochodne mogą dziedziczyć zachowania i stan swoich klas nadrzędnych, ale także mogą zmieniać te zachowanie i stan.
   I to do tego właśnie w dużej mierze sprowadza się polimorfizm.

